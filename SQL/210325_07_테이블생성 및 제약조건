-- DDL (CREATE TABLE) 및 제약조건

-- DDL (DATA DEFINITION LANGUAGE) : 데이터 정의 언어
-- "객체"(OBJECT)를 만들고(CREATE), 수정(ALTER)하고 삭제(DROP)하는 구문
-- USER도 객체여서 CREATE로 만듦. 사용자 권한 수정은 ALTER, 사용자 삭제는 DROP
-- DML에선, INSERT, UPDATE, DELETE

-- 테이블 만들기
-- [표현식] : 
-- CREATE TABLE 테이블명(컬럼명 자료형(크기), 컬럼명 자료형(크기),....);
CREATE TABLE MEMBER(
  MEMBER_ID VARCHAR2(20),
  MEMBER_PWD VARCHAR2(20),
  MEMBER_NAME VARCHAR2(20)
);
-- 테이블명 MEMBER, 안에 넣을 세 개의 컬럼

SELECT
       M.*
  FROM MEMBER M;

-- 컬럼에 주석 달기
-- [표현식] : 
-- COMMENT ON COLUMN 테이블명.컬럼명 IS '주석내용';
COMMENT ON COLUMN MEMBER.MEMBER_ID IS '회원아이디';
COMMENT ON COLUMN MEMBER.MEMBER_PWD IS '비밀번호';
COMMENT ON COLUMN MEMBER.MEMBER_NAME IS '회원이름';


--------------------------------------------------------
-- 데이터베이스에 생성되어 있는 테이블 목록 조회(시스템 테이블)
-- 테이블이 잘 생성되었는지, 값이 잘 들어갔는지
SELECT
        UT.*
  FROM USER_TABLES UT;

SELECT
       UTC.*
  FROM USER_TAB_COLUMNS UTC
 WHERE UTC.TABLE_NAME = 'MEMBER';
-- FROM절까지만 하면 모든 테이블에 대한 칼럼 볼 수 있음

DESC MEMBER;
-- 각 칼럼의 데이터 타입
--------------------------------------------------------
-- 제약조건
-- 테이블 작성 시 각 컬럼에 대해 값 기록에 대한 제약조건을 설정할 수 있다.
-- 데이터 무결성(데이터가 정확한 값) 보장을 목적으로 함
-- 입력/수정하는 데이터에 문제가 없는지 자동으로 검사하는 목적
-- PRIMARY KEY, NOT NULL, UNIQUE, CHECK, FOREIGN KEY

--------------------------------------------------------
SELECT
       UC.*
  FROM USER_CONSTRAINTS UC;
-- 제약조건을 볼 수 있음

SELECT
       UCC.*
  FROM USER_CONS_COLUMNS UCC;
-- 각각의 컬럼에 붙은 제약조건들만 볼 수 있음
--------------------------------------------------------
-- NOT NULL : 해당 컬럼에 반드시 값이 기록되어야 하는 경우 사용
--            삽입 / 수정 시 NULL 값을 허용하지 않도록
--            컬럼 레벨에서 제한 (테이블 레벨에서도 걸 수 있음)
CREATE TABLE USER_NOCONS(
  USER_NO NUMBER, 
  USER_ID VARCHAR2(20),
  USER_PWD VARCHAR2(30),
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50)
)

SELECT * FROM USER_NOCONS;

-- 테이블에 데이터 추가
--INSERT
--   INTO 테이블명
--(컬럼명, 컬럼명,...)
--VALUES
--('값','값',...)


INSERT
  INTO USER_NOCONS
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  1
, 'user01'
, 'pass01'
, '홍길동'
, '남'
, '010-1234-5678'
, 'hong123@greedy.com'
);

INSERT
  INTO USER_NOCONS
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  2
, NULL
, NULL
, NULL
, NULL
, '010-1234-5678'
, 'hong123@greedy.com'
);

COMMIT;

SELECT
       UN.*
  FROM USER_NOCONS UN;

CREATE TABLE USER_NOTNULL(
  USER_NO NUMBER NOT NULL, -- 컬럼레벨 제약조건 설정
  USER_ID VARCHAR2(20) NOT NULL,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30) NOT NULL,
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50)
);

--------------------------------------------------------
---- **********제약조건 조회(시스템 테이블)********** -----
SELECT
       UC.*
     , UCC.*
  FROM USER_CONSTRAINTS UC
  JOIN USER_CONS_COLUMNS UCC ON(UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME)
 WHERE UC.TABLE_NAME = 'USER_NOTNULL';
 -- 내가 만든 테이블의 제약조건을 가져올 수 있음
 -- WHERE을 통해 해당 테이블의 컬럼들의 제약조건을 가져올 수 있음
--------------------------------------------------------
INSERT
  INTO USER_NOTNULL
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  1
, 'user01'
, 'pass01'
, '홍길동'
, '남'
, '010-1234-5678'
, 'hong123@greedy.com'
);

SELECT * FROM USER_NOTNULL;

-- UNIQUE 제약조건 : 컬럼에 입력값에 대해 중복을 제한하는 제약조건 (중복 못 하게)
--                  컬럼레벨에서 설정 가능, 테이블 레벨에서 설정 가능

SELECT
       UN.*
  FROM USER_NOCONS UN;

INSERT
  INTO USER_NOCONS
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  2
, NULL
, NULL
, NULL
, NULL
, '010-1234-5678'
, 'hong123@greedy.com'
);

CREATE TABLE USER_UNIQUE(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20) UNIQUE NOT NULL, -- 컬럼레벨에서 제약조건 추가
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50)
);

SELECT *
  FROM USER_UNIQUE;
 
INSERT
  INTO USER_UNIQUE
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  1
, 'user01'
, 'pass01'
, '홍길동'
, '남'
, '010-1234-5678'
, 'hong123@greedy.com'
);

INSERT
  INTO USER_UNIQUE
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  1
, 'user01'
, 'pass01'
, '홍길동'
, '남'
, '010-1234-5678'
, 'hong123@greedy.com'
);
-- 오류 보고 -
-- ORA-00001: unique constraint (EMPLOYEE.SYS_C007123) violated
-- 동일한 값을 입력해줬기 때문

SELECT
       UCC.TABLE_NAME
     , UCC.COLUMN_NAME
     , UC.CONSTRAINT_TYPE
  FROM USER_CONSTRAINTS UC
     , USER_CONS_COLUMNS UCC
 WHERE UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME
   AND UCC.CONSTRAINT_NAME = 'SYS_C007123';
-- 안시 구문이 아니라 오라클 전용 구문으로 바꿔준 것
-- 276까지는 해당 테이블에 있는 모든 제약조건들을 뽑아줌
-- 테이블 네임, 컬럼 이름, 컬럼 이름에 대한 타입을 모두 뽑아줌 
-- P, C(NOTNULL), U(UNIQUE)
-- 277 중복을 없앤 상태로 제약조건을 추가해줌


CREATE TABLE USER_UNIQUE2(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20), -- 컬럼레벨에서 제약조건 추가
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50),
  UNIQUE(USER_ID) -- 테이블 레벨에서 제약조건 설정
);
-- UNIQUE 제약조건은 테이블레벨에서도 제약조건을 걸 수 있다
SELECT * FROM USER_UNIQUE2;

INSERT
  INTO USER_UNIQUE2
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  1
, 'user01'
, 'pass01'
, '홍길동'
, '남'
, '010-1234-5678'
, 'hong123@greedy.com'
);

INSERT
  INTO USER_UNIQUE2
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  1
, NULL
, 'pass01'
, '홍길동'
, '남'
, '010-1234-5678'
, 'hong123@greedy.com'
);

-- 두 개의 컬럼을 묶어서 하나의 UNIQUE 제약조건 설정
CREATE TABLE USER_UNIQUE3(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20), -- 컬럼레벨에서 제약조건 추가
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50),
  UNIQUE(USER_NO,USER_ID) -- 테이블 레벨에서 제약조건 설정
  -- 두 개로 묶었을 때 하나만 달라도 다름
);

INSERT
  INTO USER_UNIQUE3
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  1
, 'user01'
, 'pass01'
, '홍길동'
, '남'
, '010-1234-5678'
, 'hong123@greedy.com'
);

INSERT
  INTO USER_UNIQUE3
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  2
, 'user01'
, 'pass01'
, '홍길동'
, '남'
, '010-1234-5678'
, 'hong123@greedy.com'
);

INSERT
  INTO USER_UNIQUE3
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  2
, 'user02'
, 'pass01'
, '홍길동'
, '남'
, '010-1234-5678'
, 'hong123@greedy.com'
);

INSERT
  INTO USER_UNIQUE3
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  1
, 'user01'
, 'pass01'
, '홍길동'
, '남'
, '010-1234-5678'
, 'hong123@greedy.com'
);

SELECT * FROM USER_UNIQUE3;

SELECT
       UCC.TABLE_NAME
     , UCC.COLUMN_NAME
     , UC.CONSTRAINT_TYPE
  FROM USER_CONSTRAINTS UC
     , USER_CONS_COLUMNS UCC
 WHERE UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME
   AND UCC.CONSTRAINT_NAME = 'SYS_C007127';
   
-- NOT NULL 컬럼 레벨에만 사용 가능
-- UNIQUE 테이블, 컬럼 레벨 둘다 가능, 테이블 레벨에서는 두 개의 컬럼 묶을 수 있음
-- -> 여러 개의 제약조건 합칠 수 있음

-- 제약조건에 이름 설정
-- SYS~~~~ 그런 기본 제약조건 이름이 나오지 않음
-- CONSTRAINT_NAME(제약조건 이름)은 중복되면 안됨
CREATE TABLE CONS_NAME(
  TEST_DATA1 VARCHAR2(20) CONSTRAINT NN_TEST_DATA1 NOT NULL, -- 컬럼레벨에서 제약조건이름 부여
  TEST_DATA2 VARCHAR2(20) CONSTRAINT NN_TEST_DATA2 UNIQUE,
  TEST_DATA3 VARCHAR2(30),
  CONSTRAINT UN_TEST_DATA3 UNIQUE(TEST_DATA3) -- 테이블레벨에서 제약조건이름 부여
);
-- NN은 NOTNULL의 준말 뒤엔 컬럼명
   
SELECT
       UC.*
  FROM USER_CONSTRAINTS UC
 WHERE TABLE_NAME = 'CONS_NAME';
-- 테이블의 제약조건 조회 

-- CHECK 제약조건 : 컬럼에 기록되는 값에 조건 설정을 할 수 있다.
-- CHECK(컬럼명 비교연산자 비교값)
-- 주의 : 비교값은 리터럴만 사용할 수 있다. 변하는 값이나 함수는 사용 못 함. -> 특정 값으로 지정되어야
--> CHECK는 그 값만 들어올 수 있게 하는 것
CREATE TABLE USER_CHECK(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20) UNIQUE,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10) CHECK(GENDER IN ('남','여')), -- 컬럼레벨에서 CHECK제약조건 추가
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50),
  UNIQUE(USER_NO,USER_ID) -- 테이블레벨이고 제약조건의 이름이 붙지 않음
);

INSERT
  INTO USER_CHECK
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  1
, 'user01'
, 'pass01'
, '홍길동'
, '남'
, '010-1234-5678'
, 'hong123@greedy.com'
);

INSERT
  INTO USER_CHECK
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  1
, 'user01'
, 'pass01'
, '홍길동'
, '남자'
, '010-1234-5678'
, 'hong123@greedy.com'
);
-- 오류 보고 -
-- ORA-02290: check constraint (EMPLOYEE.SYS_C007132) violated

SELECT
       UC.*
     , UCC.*
  FROM USER_CONSTRAINTS UC
  JOIN USER_CONS_COLUMNS UCC ON(UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME)
 WHERE UC.CONSTRAINT_NAME = 'SYS_C007132';
-- C가 나오는데, C는 CHECK 제약조건이랑, NOT NULL 제약조건도 같이 나옴 
-- 537 시스템 계정의 테이블 목록
-- 538 시스템 계정의 해당 테이블의 컬럼들의 제약조건 (테이블레벨은 제약조건 이름 x)
  
CREATE TABLE TEST_CHECK(
  TEST_NUMBER NUMBER,
  CONSTRAINT CK_TEST_NUMBER CHECK(TEST_NUMBER > 0)
  -- CK_TEST_NUMBER는 제약조건의 이름
);

INSERT
  INTO TEST_CHECK
(
  TEST_NUMBER
)
VALUES
(
  10
);

SELECT * FROM TEST_CHECK;

INSERT
  INTO TEST_CHECK
(
  TEST_NUMBER
)
VALUES
(
  -10
);

SELECT * FROM TEST_CHECK;

CREATE TABLE TBL_CHECK(
  C_NAME VARCHAR2(10),
  C_PRICE NUMBER,
  C_LEVEL CHAR(1),
  C_DATE DATE,
  CONSTRAINT CK_C_PRICE CHECK(C_PRICE >= 1 AND C_PRICE <= 99999),
  CONSTRAINT CK_C_LEVEL CHECK(C_LEVEL = 'A' OR C_LEVEL = 'B' OR C_LEVEL = 'C'),
  CONSTRAINT CK_C_DATE CHECK(C_DATE >= TO DATE('2021/03/24', 'YYYY/MM/DD'))
);
-- CHECK 제약조건은 AND, OR, >= 등을 다 쓸 수 있다.


-- 과제
CREATE TABLE USER_TEST1(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20) CONSTRAINT NN_ID_DATA1 NOT NULL UNIQUE,
  USER_PWD VARCHAR(30) CONSTRAINT NN_ID_DATA2 NOT NULL,
  PNO NUMBER CONSTRAINT NN_ID_DATA3 NOT NULL UNIQUE,
  GENDER VARCHAR2(10) CONSTRAINT NN_ID_DATA4 CHECK(GENDER IN('남','여')),
  PHONE VARCHAR2(30),
  ADDRESS VARCHAR2(30),
  STATUS VARCHAR2(10) CONSTRAINT NN_ID_DATA5 CHECK(STATUS IN ('Y','N')) NOT NULL,
);

-- 맞는 것
CREATE TABLE USER_TEST(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20) CONSTRAINT NN_USER_ID NOT NULL,
  USER_PWD VARCHAR2(20) CONSTRAINT NN_PWD NOT NULL,
  PNO VARCHAR2(20) CONSTRAINT NN_PNO NOT NULL
  GENDER VARCHAR2(3),
  PHONE VARCHAR2(20),
  ADDRESS VARCHAR2(100),
  STATUS VARCHAR2(3) CONSTRAINT NN_PNO NOT NULL
  CONSTRAINT UK_USER_ID UNIQUE(USER_ID),
  CONSTRAINT UK_PNO UNIQUE(USER_PNO),
  CONSTRAINT CK_GENDER CHECK(GENDER IN('남','여'),
  CONSTRAINT CK_STATUS CHECK(STATUS IN('Y','N'),
-- 603에 이미 NOTNULL 제약을 걸어놔서 밑에 UNIQUE는 따로 해줘야
-- UNIQUE(이미 NOT NULL이 있을 때)랑 CHECK는 밑에 테이블 레벨에서 제약조건을 걸어줘야
);

-- NOT NULL : NN_
-- UNIQUE : UK_
-- CHECK : CK_

CREATE TABLE CONS_NAME(
  TEST_DATA1 VARCHAR2(20) CONSTRAINT NN_TEST_DATA1 NOT NULL, -- 컬럼레벨에서 제약조건이름 부여
  TEST_DATA2 VARCHAR2(20) CONSTRAINT NN_TEST_DATA2 UNIQUE,
  TEST_DATA3 VARCHAR2(30),
  CONSTRAINT UN_TEST_DATA3 UNIQUE(TEST_DATA3) -- 테이블레벨에서 제약조건이름 부여
);

INSERT
  INTO USER_TEST1
(
  USER_NO
, USER_ID
, USER_PWD
, PNO
, GENDER
, PHONE
, ADDRESS
, STATUS
)
VALUES
(
  1
, 'user01'
, 'pass01'
, 103824-104287
, '남'
, '010-1234-5678'
, '서울'
, 'Y'
);
INSERT
  INTO USER_TEST1
(
  USER_NO
, USER_ID
, USER_PWD
, PNO
, GENDER
, PHONE
, ADDRESS
, STATUS
)
VALUES
(
  2
, 'user02'
, 'pass02'
, 204824-104287
, '여'
, '010-1238-5678'
, '서울'
, 'N'
);
INSERT
  INTO USER_TEST1
(
  USER_NO
, USER_ID
, USER_PWD
, PNO
, GENDER
, PHONE
, ADDRESS
, STATUS
)
VALUES
(
  3
, 'user03'
, 'pass03'
, 103244-104287
, '남'
, '010-1544-5678'
, '경기도'
, 'N'
);
INSERT
  INTO USER_TEST1
(
  USER_NO
, USER_ID
, USER_PWD
, PNO
, GENDER
, PHONE
, ADDRESS
, STATUS
)
VALUES
(
  4
, 'user04'
, 'pass04'
, 103134-2344287
, '여'
, '010-1234-3078'
, '의왕'
, 'N'
);
INSERT
  INTO USER_TEST1
(
  USER_NO
, USER_ID
, USER_PWD
, PNO
, GENDER
, PHONE
, ADDRESS
, STATUS
)
VALUES
(
  5
, 'user05'
, 'pass05'
, 103224-204287
, '여'
, '010-1394-5678'
, '수원'
, 'N'
);


COMMENT ON COLUMN USER_TEST1.USER_NO IS '회원번호';
COMMENT ON COLUMN USER_TEST1.USER_ID IS '회원아이디';
COMMENT ON COLUMN USER_TEST1.USER_PWD IS '회원비밀번호';
COMMENT ON COLUMN USER_TEST1.PNO IS '주민등록번호';
COMMENT ON COLUMN USER_TEST1.GENDER IS '성별';   
COMMENT ON COLUMN USER_TEST1.PHONE IS '연락처';   
COMMENT ON COLUMN USER_TEST1.ADDRESS IS '주소';   
COMMENT ON COLUMN USER_TEST1.STATUS IS '탈퇴여부';




-- PRIMARY KEY(기본키) 제약조건
-- 테이블에서 한 행의 정보를 찾기 위해 사용할 컬럼을 의미함
-- 테이블에 대한 식별자 역할을 함
-- NOT NULL + UNIQUE 제약조건의 의미
-- 한 테이블 당 한 개만 설정 가능
-- 컬럼 레벨, 테이블 레벨 둘 다 설정 가능
-- 한 개 컬럼에 설정할 수도 있고, 여러 개의 컬럼을 묶어서도 설정 가능
-- 기본키 잘 실행 안 됨

CREATE TABLE USER_PRIMARYKEY(
  USER_NO NUMBER CONSTRAINT PK_USER_NO PRIMARY KEY, -- 컬럼레벨
  USER_ID VARCHAR2(20) UNIQUE,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50)
);

INSERT 
  INTO USER_PRIMARYKEY
(
  USER_NO, USER_ID, USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL
)
VALUES 
(
  1, 'user01','pass01'
, '홍길동','남','010-1234-5678'
, 'hong123@greedy.com'
);

INSERT 
  INTO USER_PRIMARYKEY
(
  USER_NO, USER_ID, USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL
)
VALUES 
(
  2, 'user02','pass02'
, '이순신','남','010-1234-5678'
, 'lee123@greedy.com'
);


INSERT 
  INTO USER_PRIMARYKEY
(
  USER_NO, USER_ID, USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL
)
VALUES 
(
  NULL, 'user02','pass02'
, '이순신','남','010-1234-5678'
, 'lee123@greedy.com'
);

SELECT
       UC.TABLE_NAME
     , UCC.COLUMN_NAME
     , UC.CONSTRAINT_NAME
     , UC.CONSTRAINT_TYPE
  FROM USER_CONSTRAINTS UC
  JOIN USER_CONS_COLUMNS UCC ON(UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME)
 WHERE UC.TABLE_NAME = 'USER_PRIMARYKEY';
DROP TABLE USER_PRIMARYKEY2;



CREATE TABLE USER_PRIMARYKEY2(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20),
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50),
  CONSTRAINT PK_USER_NO3 PRIMARY KEY(USER_NO,USER_ID)
);

INSERT 
  INTO USER_PRIMARYKEY2
(
  USER_NO, USER_ID, USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL
)
VALUES 
(
  1, 'user01','pass01'
, '이순신','남','010-1234-5678'
, 'lee123@greedy.com'
);

INSERT 
  INTO USER_PRIMARYKEY2
(
  USER_NO, USER_ID, USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL
)
VALUES 
(
  1, 'user02','pass02'
, '홍길동','남','010-1234-5678'
, 'hong23@greedy.com'
);

INSERT 
  INTO USER_PRIMARYKEY2
(
  USER_NO, USER_ID, USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL
)
VALUES 
(
  2, 'user01','pass01'
, '유관순','여','010-1234-5678'
, 'yoo23@greedy.com'
);
SELECT * FROM USER_PRIMARYKEY2;

-- FOREIGN KEY(외부키/외래키) 제약조건:
-- 참조(REFERENCE)된 다른 테이블에서 제공하는 값만 사용 가능
-- 참조 무결성을 위배하지 않게 하기 위해 사용
-- FOREIGN KEY 제약조건에 의해서 테이블 간의 관계가 형성됨 
-- 제공되는 값 외에는 NULL을 사용할 수 있다.

-- 컬럼레벨인 경우
-- 컬럼명 자료형(크기) [CONSTRAINT 이름] REFERENCES 참조할테이블명 [(참조할컬럼)] [삭제롤]

-- 테이블 레벨일 경우
-- [CONSTRAINT 이름] FOREIGN KEY (적용할 컬럼명) REFERECES 참조할테이블명[(참조할컬럼)] [삭제롤] 

-- 참조할 테이블의 참조할 컬럼명이 생략되면 PRIMARY KEY로 설정된 컬럼이 자동 참조할 컬럼이 됨
-- PRIMARY KEY로 설정된 컬럼이 자동 참조할 컬럼이 된다.
-- 참조될 수 있는 컬럼은 PRIMARY KEY 컬럼과, UNIQUE지정된 컬럼만 외래키로 참조할 수 있다.
CREATE TABLE USER_GRADE(
  GRADE_CODE NUMBER PRIMARY KEY,
  GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT
  INTO USER_GRADE
(
  GRADE_CODE
, GRADE_NAME
)
VALUES
(
  10
, '일반회원'
);

INSERT
  INTO USER_GRADE
(
  GRADE_CODE
, GRADE_NAME
)
VALUES
(
  20
, '우수회원'
);

INSERT
  INTO USER_GRADE
(
  GRADE_CODE
, GRADE_NAME
)
VALUES
(
  30
, '특별회원'
);

COMMIT;
SELECT * FROM USER_GRADE;

CREATE TABLE USER_FOREIGNKEY(
  USER_NO NUMBER PRIMARY KEY,
  USER_ID VARCHAR2(20) UNIQUE,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50),
  GRADE_CODE NUMBER,
  CONSTRAINT FK_GRADE_CODE FOREIGN KEY(GRADE_CODE) REFERENCES USER_GRADE(GRADE_CODE)
);

INSERT
  INTO USER_FOREIGNKEY
(
  USER_NO, USER_ID, USER_PWD
, USER_NAME, GENDER, PHONE
,EMAIL, GRADE_CODE
)
VALUES
(
  1,'user01','pass01'
,'홍길동','남','010-1234-5678'
,'hong123@greedy.com','10'
);

INSERT
  INTO USER_FOREIGNKEY
(
  USER_NO, USER_ID, USER_PWD
, USER_NAME, GENDER, PHONE
,EMAIL, GRADE_CODE
)
VALUES
(
  2,'user02','pass02'
,'이순신','남','010-1234-5678'
,'lee123@greedy.com','10'
);

INSERT
  INTO USER_FOREIGNKEY
(
  USER_NO, USER_ID, USER_PWD
, USER_NAME, GENDER, PHONE
,EMAIL, GRADE_CODE
)
VALUES
(
  3,'user03','pass03'
,'유관순','여','010-1234-5678'
,'yoo123@greedy.com','30'
);

INSERT
  INTO USER_FOREIGNKEY
(
  USER_NO, USER_ID, USER_PWD
, USER_NAME, GENDER, PHONE
,EMAIL, GRADE_CODE
)
VALUES
(
  4,'user04','pass04'
,'안중근','남','010-1234-5678'
,'ahn123@greedy.com',null
);

INSERT
  INTO USER_FOREIGNKEY
(
  USER_NO, USER_ID, USER_PWD
, USER_NAME, GENDER, PHONE
,EMAIL, GRADE_CODE
)
VALUES
(
  5,'user05','pass05'
,'윤봉길','남','010-1234-5678'
,'yoon123@greedy.com',50
);
-- 부모쪽에서 가지고 있지 않은 값을 추가하려고 하면 오류
-- 50은 부모쪽에 없음

commit;

-- 삭제 옵션
-- 부모테이블의 데이터 삭제 시 자식테이블의 데이터를
-- 어떤 식으로 처리할 지에 대한 내용을 설정할 수 있다.
-- ON DELETE RESTRICTED로 기본 지정되어 있다.
-- FOREIGN KEY로 지정된 컬럼에서 사용되고 있는 값일 경우
-- 제공하는 컬럼의 값은 삭제 못함
DELETE
  FROM USER_GRADE
 WHERE GRADE_CODE = 20;
 
SELECT
       UC.*
  FROM USER_GRADE UC;
ROLLBACK;
SELECT * FROM USER_FOREIGNKEY;

-- ON DELETE SET NULL : 부모키를 삭제 시 자식키를 NULL로 변경하는 옵션
-- ON DELETE SET NULL : 부모키를 삭제 시 자식키를 NULL로 변경하는 옵션
CREATE TABLE USER_GRADE2(
  GRADE_CODE NUMBER PRIMARY KEY,
  GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT
  INTO USER_GRADE2
(
  GRADE_CODE
, GRADE_NAME
)
VALUES 
(
  10
, '일반회원'
);

INSERT
  INTO USER_GRADE2
(
  GRADE_CODE
, GRADE_NAME
)
VALUES 
(
  20
, '우수회원'
);

INSERT
  INTO USER_GRADE2
(
  GRADE_CODE
, GRADE_NAME
)
VALUES 
(
  30
, '특별회원'
);
SELECT * FROM USER_GRADE2;

CREATE TABLE USER_FOREIGNKEY2(
  USER_NO NUMBER PRIMARY KEY,
  USER_ID VARCHAR2(20) UNIQUE,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50),
  GRADE_CODE NUMBER,
  CONSTRAINT FK_GRADE_CODE2 FOREIGN KEY(GRADE_CODE) 
  REFERENCES USER_GRADE2(GRADE_CODE) ON DELETE SET NULL
);


INSERT
  INTO USER_FOREIGNKEY2
(
  USER_NO,USER_ID,USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL, GRADE_CODE
)
VALUES
(
  1,'user01','pass01'
, '홍길동','남','010-1234-5678'
, 'hong123@greedy.com',10
);

INSERT
  INTO USER_FOREIGNKEY2
(
  USER_NO,USER_ID,USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL, GRADE_CODE
)
VALUES
(
  2,'user02','pass02'
, '이순신','남','010-1234-5678'
, 'lee123@greedy.com',10
);

INSERT
  INTO USER_FOREIGNKEY2
(
  USER_NO,USER_ID,USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL, GRADE_CODE
)
VALUES
(
  3,'user03','pass03'
, '유관순','여','010-1234-5678'
, 'yoo123@greedy.com',30
);

INSERT
  INTO USER_FOREIGNKEY2
(
  USER_NO,USER_ID,USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL, GRADE_CODE
)
VALUES
(
  4,'user04','pass04'
, '안중근','남','010-1234-5678'
, 'ahn123@greedy.com',null
);

COMMIT;

DELETE
  FROM USER_GRADE2
 WHERE GRADE_CODE = 10;

SELECT
       UG.*
  FROM USER_GRADE2 UG;
  
SELECT
       UF.*
  FROM USER_FOREIGNKEY2 UF;
  

-- ON DELETE SET NULL이라는 삭제롤을 붙여주면 부모쪽의 컬럼을 삭제하면 참조하는 자식의 컬럼은 NULL
-- 이 부분 작성 못 했음.





 -- ON DELETE CASCADE :  부모키 삭제 시 자식키를 가진 행도 함께 삭제
  CREATE TABLE USER_GRADE3(
  GRADE_CODE NUMBER PRIMARY KEY,
  GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT
  INTO USER_GRADE3
(
  GRADE_CODE
, GRADE_NAME
)
VALUES 
(
  10
, '일반회원'
);

INSERT
  INTO USER_GRADE3
(
  GRADE_CODE
, GRADE_NAME
)
VALUES 
(
  20
, '우수회원'
);

INSERT
  INTO USER_GRADE3
(
  GRADE_CODE
, GRADE_NAME
)
VALUES 
(
  30
, '특별회원'
);
 
SELECT * FROM USER_GRADE3;
 
 CREATE TABLE USER_FOREIGNKEY3(
  USER_NO NUMBER PRIMARY KEY,
  USER_ID VARCHAR2(20) UNIQUE,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50),
  GRADE_CODE NUMBER,
  CONSTRAINT FK_GRADE_CODE3 FOREIGN KEY(GRADE_CODE) 
  REFERENCES USER_GRADE3(GRADE_CODE) ON DELETE CASCADE
);


INSERT
  INTO USER_FOREIGNKEY3
(
  USER_NO,USER_ID,USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL, GRADE_CODE
)
VALUES
(
  1,'user01','pass01'
, '홍길동','남','010-1234-5678'
, 'hong123@greedy.com',10
);

INSERT
  INTO USER_FOREIGNKEY3
(
  USER_NO,USER_ID,USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL, GRADE_CODE
)
VALUES
(
  2,'user02','pass02'
, '이순신','남','010-1234-5678'
, 'lee123@greedy.com',10
);

INSERT
  INTO USER_FOREIGNKEY3
(
  USER_NO,USER_ID,USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL, GRADE_CODE
)
VALUES
(
  3,'user03','pass03'
, '유관순','여','010-1234-5678'
, 'yoo123@greedy.com',30
);

INSERT
  INTO USER_FOREIGNKEY3
(
  USER_NO,USER_ID,USER_PWD
, USER_NAME, GENDER, PHONE
, EMAIL, GRADE_CODE
)
VALUES
(
  4,'user04','pass04'
, '안중근','남','010-1234-5678'
, 'ahn123@greedy.com',null
);

COMMIT;

DELETE
  FROM USER_GRADE3
 WHERE GRADE_CODE = 10;
 
SELECT
       UG.*
  FROM USER_GRADE3 UG;

SELECT
       UF.*
  FROM USER_FOREIGNKEY3 UF;

-- 서브쿼리를 이용한 테이블 생성
CREATE TABLE EMPLOYEE_COPY
AS
SELECT
        E.*
  FROM EMPLOYEE E;

SELECT
        EC.*
  FROM EMPLOYEE_COPY EC;

-- 컬럼명, 데이터 타입, 값이 복사되고, 제약조건은 NOT NULL만 복사됨
CREATE TABLE EMPLOYEE_COPY2
AS
SELECT
       E.EMP_ID
     , E.EMP_NAME
     , E.SALARY
     , D.DEPT_TITLE
     , J.JOB_NAME
  FROM EMPLOYEE E
  LEFT JOIN DEPARTMENT D ON(E.DEPT_CODE = D.DEPT_ID)
  LEFT JOIN JOB J ON (E.JOB_CODE = J.JOB_CODE);
  
SELECT
       EC.*
  FROM EMPLOYEE_COPY2 EC;

-- 제약조건 추가
-- ALTER TABLE 테이블명 ADD PRIMARY KEY(컬럼명);
-- ALTER TABLE 테이블명 ADD FOREIGN KEY(컬럼명) REFERENCES 테이블명(컬럼명);
-- ALTER TABLE 테이블명 ADD UNIQUE(컬럼명);
-- ALTER TABLE 테이블명 ADD CHECK(컬럼명 비교연산자 비교값);
-- ALTER TABLE 테이블명 MODIFY 컬럼명 NOT NULL;
ALTER TABLE EMPLOYEE_COPY ADD PRIMARY KEY(EMP_ID);


-- 실습
-- EMPLOYEE 테이블의 DEPT_CODE에 외래키 제약조건 추가
-- 참조 테이블은 DEPARTMENT, 참조컬럼은 DEPARTMENT의 기본키
-- DEPARTMENT 테이블의 LOCATION_ID에 외래키 제약조건 추가
-- 참조 테이블은 LOCATION, 참조 컬럼은 LOCATION의 기본키
-- EMPLOYEE 테이블의 JOB_CODE에 외래키 제약조건 추가
-- 참조 테이블은 JOB 테이블, 참조 컬럼은 JOB테이블의 기본키
-- EMPLOYEE 테이블의 SAL_LEVEL에 외래키 제약조건 추가
-- 참조테이블은 SAL_GRADE테이블, 참조 컬럼은 SAL_GRADE테이블 기본키
-- EMPLOYEE테이블의 ENT_YN컬럼에 CHECK제약조건 추가('Y','N')
-- 단, 대 소문자를 구분하기 때문에 대문자로 설정
-- EMPLOYEE테이블의 SALARY 컬럼에 CHECK제약조건 추가(양수)
-- EMPLOYEE테이블의 EMP_NO컬럼에 UNIQUE 제약조건 추가
CREATE TABLE EMPLOYEE_FOREIGNKEY(
  DEPT_CODE VARCHAR2(10),
  CONSTRAINT FK_DEPT_CODE FOREIGN KEY REFERENCES DEPARTMENT(DEPARTMENT_PK) 
  LOCATION_ID VARCHAR2(10)
  CONSTRAINT FK_LOCATION_ID FOREIGN KEY REFERENCES LOCATION(LOCATION_PK)
  JOB_CODE VARCHAR2(10)
  CONSTRAINT FK_JOB_CODE FOREIGN KEY REFERENCES JOB(JOB_PK)
  SAL_LAVEL VARCHAR2(10)
  CONSTRAINT FK_SAL_LEVEL FOREIGN KEY REFERENCES SAL_GRADE(엔터티2_PK)
  
  REFERENCES DEPARTMENT(DEPARTMENT_PK) ON DELETE CASCADE
);
-- 컬럼레벨인 경우
-- 컬럼명 자료형(크기) [CONSTRAINT 이름] REFERENCES 참조할테이블명 [(참조할컬럼)] [삭제롤]

-- 테이블 레벨일 경우
-- [CONSTRAINT 이름] FOREIGN KEY (적용할 컬럼명) REFERECES 참조할테이블명[(참조할컬럼)] [삭제롤] 

SELECT * FROM USER_CONSTRAINTS; -- 계정이 소유한 모든 제약을 가지고 있는 시스템 테이블
SELECT * FROM USER_CONS_COLUMNS; -- 칼럼이 할당되어 있는 제약조건을 가지고 있는 시스템 테이블


ALTER TABLE EMPLOYEE ADD FOREIGN KEY(DEPT_CODE) REFERENCES DEPARTMENT(DEPT_ID);
ALTER TABLE DEPARTMENT ADD FOREIGN KEY(LOCATION_ID) REFERENCES LOCATION(LOCAL_CODE);
ALTER TABLE EMPLOYEE ADD FOREIGN KEY(JOB_CODE) REFERENCES JOB(JOB_CODE);
ALTER TABLE EMPLOYEE ADD FOREIGN KEY(SAL_LEVEL) REFERENCES SAL_GRADE(SAL_LEVEL);
ALTER TABLE EMPLOYEE ADD CHECK (ENT_YN IN ('Y', 'N'));
ALTER TABLE EMPLOYEE ADD CHECK(SALARY > 0);
ALTER TABLE EMPLOYEE ADD UNIQUE(EMP_NO);



